<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title></title></head><body>
<script type="module">

//#region IMPORTS
import Starter, { THREE }   from '../threejs/_lib/Starter.js';
import Proto                from './lib/Proto.js';

import Gltf2                from '../../src/parsers/gltf2/index'
//#endregion

//#region MAIN
let App;

window.addEventListener( "load", async _=>{
    App = new Starter( { webgl2:true, grid:true } );
    App.setCamera( 0, 20, 1.5, [0,0.8,0] );
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    xfetch( '../_res/models/readyplayerme.glb' );

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App.render();
});
//#endregion


/*
- Give Google 5 days that I'm available for Tech Review
- Write Health Insurance Check
- Write Quarterly Taxes Checks
*/

import SkinMTXMaterial  from '../threejs/_lib/SkinMTXMaterial.js';
import { Armature, SkinMTX }    from '../../src/armature/index';

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#glb-file-format-specification-general

const GLB_MAGIC	            = 0x46546C67;   // Simple number test to see if its a GLB
const GLB_JSON	            = 0x4E4F534A;   // Chunk Type for JSON
const GLB_BIN	            = 0x004E4942;   // Chunk Type for Binary
const GLB_VER               = 2;            // Version Number
const GLB_MAGIC_BIDX        = 0;            // Byte Index for magic Uint32 magic value
const GLB_VERSION_BIDX      = 4;            // Byte Index for version Uint32 Value
const GLB_JSON_TYPE_BIDX    = 16;           // Byte Index for Chunk0 Type 
const GLB_JSON_LEN_BIDX     = 12;           // Byte Index for Chunk0 ByteLength ( Start of Header )
const GLB_JSON_BIDX         = 20;           // Byte Index for the start of Chunk0

async function xfetch( url ){
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const arybuf    = await fetch( url ).then( r=>r.arrayBuffer() );
    const dv        = new DataView( arybuf );

    if( dv.getUint32( GLB_MAGIC_BIDX, true ) != GLB_MAGIC ){    console.error( 'GLB magic number does not match.' );    return null; }
    if( dv.getUint32( GLB_VERSION_BIDX, true ) != GLB_VER ){    console.error( 'Can only accept GLB of version 2.' );   return null; }
    if( dv.getUint32( GLB_JSON_TYPE_BIDX, true ) != GLB_JSON ){ console.error( 'GLB Chunk 0 is not the type: JSON ');   return null; }

    const json_len    = dv.getUint32( GLB_JSON_LEN_BIDX, true );    // Byte Length of Chunk0-JSON
    const chk1_bidx   = GLB_JSON_BIDX + json_len;	                // Byte Index for Chunk1's Header ( Also Chunk1's ByteLength )

     // TODO: This isn't actually required, can have GLTF without Binary Chunk
    if( dv.getUint32( chk1_bidx + 4, true ) != GLB_BIN ){       console.error( 'GLB Chunk 1 is not the type: BIN ' );return null; }
    
    const bin_len = dv.getUint32( chk1_bidx, true );    // Get Length of Binary Chunk
    const bin_idx = chk1_bidx + 8;                      // Skip the 2 INT header values to get the byte index start of BIN

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // PARSE JSON
    const txt_decoder   = new TextDecoder( 'utf8' );                            // JSON is encoded with uf8
    const json_bytes    = new Uint8Array( arybuf, GLB_JSON_BIDX, json_len );    // Slice the Byte Array to just have the JSON Chunk
    const json_text     = txt_decoder.decode( json_bytes );                     // Decode Byte Array Slice
    const json          = JSON.parse( json_text );                              // Parse Text to JSON Objects

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // PARSE BIN - TODO, Not efficent to slice the array buffer
    // Ideally better to save start index as a starting offset
    // & fix the parser to tack that value onto every accessor call

    const bin = arybuf.slice( bin_idx );
    if( bin.byteLength != bin_len ){ console.error( 'GLB Bin length does not match value in header.' ); return null; }
    
    ReadyPlayerMe.parse( new Gltf2( json, bin ) );
}


class ReadyPlayerMe{
    static parse( gltf ){
        const rtn   = {};
        rtn.arm     = this.armatureFromJson( gltf );
        rtn.mesh    = this.parseMeshNodes( gltf, rtn.arm );
        App.add( rtn.mesh );
    }

    /** Convert all Mesh Nodes to Renderable 3JS Meshes */
    static parseMeshNodes( gltf, arm ){
        const aryNodes      = gltf.json.nodes.filter( i=>( i.skin !== undefined && i.mesh !== undefined ) );
        const skinOffsets   = arm.getSkinOffsets()[0];
        const grp           = new THREE.Group();
        const texMap        = new Map();
        let n;
        let p;
        let m;
        let g;
        let gl_m;     // GLTF Material
        let mesh;
        let mat;
        let tex;
        let texId;

        const fnTex = ( idx )=>{
            const gl_tex = gltf.getTexture( idx );  // Parse Texture Data + Blob
            const tex    = new THREE.Texture();     // Start a 3JS Texture
            const img    = new Image();             // Start image to put into 3js texture

            tex.name     = gl_tex.name;
            tex.flipY    = false; 

            img.name     = gl_tex.name; 
            img.src      = URL.createObjectURL( gl_tex.blob ); // Have image Load Blob
            img.onload   = ()=>{
                tex.image       = img;  // Update Texture when Image is ready
                tex.needsUpdate = true;
            }

            texMap.set( idx, tex );     // Save to map, other mesh can reuse textures.
            return tex;
        };

        // Each mesh item should only have a single primitive, if its always true
        // we can skip looping over the array & just grab the first item.
        for( n of aryNodes ){
            //------------------------------------------
            m           = gltf.getMesh( n.mesh );                   // Get Mesh Primitives
            p           = m.primitives[ 0 ];                        // Just Grab the First Primitive
            
            gl_m        = gltf.getMaterial( p.materialIdx );
            texId       = gl_m.baseColorTexture.index;
            tex         = ( texMap.has( texId ) )? texMap.get( texId ) : fnTex( texId );
            
            //------------------------------------------
            g           = this.primitive2Geo( p );                  // Create 3JS BufferGeometry
            g.name      = 'geo_' + m.name;                          // ... name it for shitz
            
            //------------------------------------------
            mat         = SkinMTXMaterial( tex, skinOffsets );      // new THREE.MeshPhongMaterial( {color:0x00ffff } );
            mesh        = new THREE.Mesh( g, mat );                 // Create a 3JS mesh
            mesh.name   = m.name;                                   // ... name it
            
            //------------------------------------------
            grp.add( mesh );                                        // Group all Primitives together, Forms 1 Character
        }

        return grp;
    }

    /** Convert GLTF Primitives to 3JS BufferGeometry */
    static primitive2Geo( prim ){
        const geo = new THREE.BufferGeometry();
        geo.setAttribute( 'position', new THREE.BufferAttribute( prim.position.data, prim.position.componentLen ) );

        if( prim.indices )    geo.setIndex( new THREE.BufferAttribute( prim.indices.data, 1 ) );
        if( prim.normal )     geo.setAttribute( 'normal', new THREE.BufferAttribute( prim.normal.data, prim.normal.componentLen ) );
        if( prim.texcoord_0 ) geo.setAttribute( 'uv', new THREE.BufferAttribute( prim.texcoord_0.data, prim.texcoord_0.componentLen ) );

        if( prim.joints_0 && prim.weights_0 ){
            geo.setAttribute( 'skinWeight', new THREE.BufferAttribute( prim.weights_0.data, prim.weights_0.componentLen ) );
            geo.setAttribute( 'skinIndex',  new THREE.BufferAttribute( prim.joints_0.data, prim.joints_0.componentLen ) );
        }
        return geo;
    }

    /** Parse out the Skin Data & Create an Armature Object out of it */
    static armatureFromJson( gltf, defaultBoneLen = 0.07 ){
        const skin = gltf.getSkin();
        const arm  = new Armature();
        
        // Create Armature
        for( let j of skin.joints ){
            arm.addBone( j.name, j.parentIndex, j.rotation, j.position, j.scale );
        }

        // Bind
        arm.bind( SkinMTX, defaultBoneLen );

        // Save Offsets if available
        arm.offset.set( skin.rotation, skin.position, skin.scale );
        return arm;
    }
}

</script>
</body></html>